#!/usr/bin/env Rscript
options(stringsAsFactors = FALSE)
suppressMessages(library("argparse"))
suppressMessages(library("pander"))

code_dir <- dirname(
  sub("--file=", "", grep("--file=", commandArgs(trailingOnly = FALSE), value = TRUE)))
  
#' Set up and gather command line arguments
parser <- ArgumentParser(
  description = "R-based nucleotide sequence coupler for paired-end sequences aligned by BLAT.")
parser$add_argument(
  "anchorPSL", nargs = 1, type = "character", default = NULL,
  help = "Alignment file (psl format) to couple, component of paired-end sequence that is anchored to a biological phenomenon.")
parser$add_argument(
  "adriftPSL", nargs = 1, type = "character", default = NULL,
  help = "Alignment file (psl format) to couple, other component of paired-end sequnece that is generated by non-natural forces (shearing).")
parser$add_argument(
  "-k", "--key", nargs = "*", type = "character", default = NULL,
  help = "Key files which denote the consolidation of reads to unique sequences. See README for requirements. Mulitple key files should be input in the same order as their respective psl files.")
parser$add_argument(
  "-o", "--uniqOutput", nargs = 1, type = "character", default = NULL,
  help = "Output file for unique alignments. File types supported: .rds, .RData, .csv, and .tsv")
parser$add_argument(
  "--condSites", nargs = 1, type = "character", default = NULL, 
  help = "Output file for condensed sites, based on anchor alignments. Read counts and unique alignment length counts are reported for each unique site. Same file types supported as uniqOutput.")
parser$add_argument(
  "--chimeras", nargs = 1, type = "character", default = NULL, 
  help = "Output file for chimeric alignments. Same file types supported as uniqOutput.")
parser$add_argument(
  "--multihits", nargs = 1, type = "character", default = NULL, 
  help = "Output file for multihit alignments. Same file types supported as uniqOutput.")
parser$add_argument(
  "-g", "--refGenome", nargs = 1, type = "character", default = "hg38",
  help = "Reference genome, needs to be installed through BSgenome (BioConductor).")
parser$add_argument(
  "--maxAlignStart", nargs = 1, type = "integer", default = 5L,
  help = "Maximum allowable distance from the start of the sequence to keep the alignment. Default = 5.")
parser$add_argument(
  "--minPercentIdenity", nargs = 1, type = "integer", default = 95L,
  help = "Minimal global (whole sequence) percent identity required to keep alignment. Default = 95 (0-100).")
parser$add_argument(
  "--minTempLength", nargs = 1, type = "integer", default = 30L,
  help = "Minimum value for paired template length to consider. Default = 30 (bps).")
parser$add_argument(
  "--maxTempLength", nargs = 1, type = "integer", default = 2500L,
  help = "Maximum value for paired template length to consider. Default = 2500 (bps).")
parser$add_argument(
  "--readNamePattern", nargs = 1, type = "character", default = "[\\w:-]+",
  help = "Regular expression for pattern matching read names. Should not contain R1/R2/I1/I2 specific components. Default is [\\w:-]+")

args <- parser$parse_args(commandArgs(trailingOnly = TRUE))
  










  processBLATData <- function(algns, from, refGenome){
    stopifnot(from == "R1" | from == "R2")
    algns$from <- from
    algns$qtStart <- ifelse(
      algns$strand == "+",
      (algns$tStart - (algns$qStart)),
      (algns$tStart - (algns$qSize - algns$qEnd - 1)))
    algns$qtEnd <- ifelse(
      algns$strand == "+",
      (algns$tEnd + (algns$qSize - algns$qEnd - 1)),
      (algns$tEnd + (algns$qStart)))    
    
    algns.gr <- GRanges(seqnames=Rle(algns$tName),
                        ranges = IRanges(
                          start = (algns$qtStart + 1), 
                          end = (algns$qtEnd)), #Convert to 1-base
                        strand=Rle(algns$strand),
                        seqinfo=seqinfo(get_reference_genome(refGenome)))
    
    mcols(algns.gr) <- algns[,c("from", "qName", "matches", "repMatches", 
                                "misMatches", "qStart", "qEnd", "qSize", 
                                "tBaseInsert")]
    rm(algns)
    algns.gr
  }
  
  load("keys.RData")
  load("stats.RData")
  
  psl.R2 <- list.files(".", pattern="R2.*.fa.psl.gz")
  message("R2 psl:\n", paste(psl.R2, collapse="\n"),"\n")
  hits.R2 <- readpsl(psl.R2)

  psl.R1 <- list.files(".", pattern="R1.*.fa.psl.gz")
  message("R1 psl:\n", paste(psl.R1, collapse="\n"),"\n")
  hits.R1 <- readpsl(psl.R1)
  
  #' Record the number of reads with R1 and R2 alignments
  readsAligning <- length(
    which(keys$R2 %in% hits.R2$qName & keys$R1 %in% hits.R1$qName))
  stats <- cbind(stats, readsAligning)
  save(stats, file="stats.RData")
  
  #' Quality filter and convert alignments from data.frame to GRanges
  hits.R2 <- qualityFilter(hits.R2, maxAlignStart, minPercentIdentity)
  hits.R2 <- processBLATData(hits.R2, "R2", refGenome)   
  save(hits.R2, file="hits.R2.RData")
  
  hits.R1 <- qualityFilter(hits.R1, maxAlignStart, minPercentIdentity)
  hits.R1 <- processBLATData(hits.R1, "R1", refGenome)
  save(hits.R1, file="hits.R1.RData")
  
  #no more '.p' or '.l' nomenclature here
  #we're combining alignments from both sides of the read

  #' All alignments should be either "+" or "-" strand.  
  stopifnot(all(strand(hits.R1) == "+" | strand(hits.R1) == "-"))
  stopifnot(all(strand(hits.R2) == "+" | strand(hits.R2) == "-"))
  
  #' Record the number of reads passing quality filtering
  readsWithGoodAlgnmts <- length(
    which(keys$R2 %in% hits.R2$qName & keys$R1 %in% hits.R1$qName))
  stats <- cbind(stats, readsWithGoodAlgnmts)
  save(stats, file="stats.RData")
  
  #' Identify all combinations of unique R1 and R2 sequences present in the data
  unique_key_pairs <- unique(keys[,c("R1", "R2", "readPairKey")])

  #' Reduced alignments identify the distinct genomic locations present in the 
  #' data for the R1 sequences (breakpoint positions) and R2 sequences 
  #' (integration site position). 
  #' Levels: Reads --> Unique Sequences --> Alignments --> Unique Genomic Loci
  red.hits.R1 <- reduce(
    flank(hits.R1, -1, start = TRUE), min.gapwidth = 0L, with.revmap = TRUE)

  red.hits.R2 <- reduce(
    flank(hits.R2, -1, start = TRUE), min.gapwidth = 0L, with.revmap = TRUE)
  
  #' The following finds all posible combinations of R1 and R2 loci which meet
  #' criteria for pairing. These include: oneEach (each pairing must come from
  #' one R1 and one R2 loci), opposite strands (paired loci should be present on
  #' opposite strands), and correct downstream orientation (if an R2 loci is on 
  #' the "+" strand, then the start of the R2 loci should be less than the 
  #' paired R1, and vice versa for "-" strand).
  #' (Inherent check for oneEach with findOverlaps())
  pairs <- findOverlaps(
    red.hits.R1,
    red.hits.R2,
    maxgap = maxLength,
    ignore.strand = TRUE
  )
  
  R1.loci <- red.hits.R1[queryHits(pairs)]
  R2.loci <- red.hits.R2[subjectHits(pairs)]
  
  #' Check isDownstream and isOppositeStrand
  R1.loci.starts <- start(R1.loci)
  R2.loci.starts <- start(R2.loci)
  
  R1.loci.strand <- strand(R1.loci)
  R2.loci.strand <- strand(R2.loci)
  
  keep.loci <- ifelse(
      R2.loci.strand == "+", 
      as.vector(R1.loci.starts > R2.loci.starts & 
                  R1.loci.strand != R2.loci.strand), 
      as.vector(R1.loci.starts < R2.loci.starts & 
                  R1.loci.strand != R2.loci.strand))
  
  keep.loci <- as.vector(
    keep.loci & R2.loci.strand != "*" & R1.loci.strand != "*")
  
  R1.loci <- R1.loci[keep.loci]
  R2.loci <- R2.loci[keep.loci]
  
  #' Below, the code constructs a genomic loci key which links genomic loci to
  #' the various R1 and R2 sequences that were aligned.
  loci.key <- data.frame(
    "R1.loci" = queryHits(pairs)[keep.loci],
    "R2.loci" = subjectHits(pairs)[keep.loci])
  loci.key$lociPairKey <- paste0(loci.key$R1.loci, ":", loci.key$R2.loci)
  
  loci.key$R1.qNames <- IntegerList(lapply(R1.loci$revmap, function(x){
    as.integer(hits.R1$qName[x])
  }))
  
  loci.key$R2.qNames <- IntegerList(lapply(R2.loci$revmap, function(x){
    as.integer(hits.R2$qName[x])
  }))
  
  loci.key$R1.readPairs <- IntegerList(lapply(
    loci.key$R1.qNames, function(x){
      which(unique_key_pairs$R1 %in% x)
  }))
  
  loci.key$R2.readPairs <- IntegerList(lapply(
    loci.key$R2.qNames, function(x){
      which(unique_key_pairs$R2 %in% x)
  }))
  
  #' Using the range information from the filtered paired alignments, the code
  #' constructs a GRanges object from the R1.loci and R2.loci. R2.loci are the 
  #' integration site positions while the R1.loci are the various breakpoints.
  #' The strand of the range is set to the same strand as the R2.loci since the
  #' direction of sequencing from the viral or vector genome is from the U5-host
  #' junction found at the 3' end of the integrated element.
  paired.loci <- GRanges(
    seqnames = seqnames(R2.loci), 
    ranges = IRanges(
      start = ifelse(strand(R2.loci) == "+", start(R2.loci), start(R1.loci)),
      end = ifelse(strand(R2.loci) == "+", end(R1.loci), end(R2.loci))),
    strand = strand(R2.loci),
    lociPairKey = loci.key$lociPairKey)
  
  paired.loci$readPairKeys <- CharacterList(lapply(
    1:length(paired.loci), 
    function(i){
      unique_key_pairs[intersect(
        loci.key$R1.readPairs[[i]], 
        loci.key$R2.readPairs[[i]]),
        "readPairKey"]
  }))
  
  #' Remove R1:R2 pairings that do not appear in the sequence data
  paired.loci <- paired.loci[sapply(paired.loci$readPairKeys, length) > 0]

  #' Expand readPairKeys and lociPairKeys to make a single object that maps loci
  #' to unique sequences. This is analogous to a sparse matrix, but in a 
  #' data.frame object. The keys object is still needed to jump from readPairKey
  #' to read name.
  read.loci.mat <- data.frame(
    "lociPairKey" = Rle(
      values = paired.loci$lociPairKey,
      lengths = sapply(paired.loci$readPairKeys, length)),
    "readPairKey" = unlist(paired.loci$readPairKeys)
  )
  
  #' Record the number of alignments that have been properly paired and passed
  #' filtering criteria.
  numProperlyPairedAlignments <- nrow(
    keys[keys$readPairKey %in% read.loci.mat$readPairKey,])
  stats <- cbind(stats, numProperlyPairedAlignments)
  save(stats, file="stats.RData")
  
  #' Templates aligning to single loci are termed unique, while templates
  #' aligning to multiple loci are termed multihits.
  readPairCounts <- table(read.loci.mat$readPairKey)
  uniq.readPairs <- names(readPairCounts[readPairCounts == 1])
  multihit.readPairs <- names(readPairCounts[readPairCounts > 1])

  #' ########## IDENTIFY IMPROPERLY-PAIRED READS (chimeras) ##########
  #' Further, all unique and multihit templates were mapped successfully to 
  #' genomic loci, yet some templates were sequenced but did not make it through
  #' the selection criteria. These template either do not have alignments to the
  #' reference genome (R1 or R2 did not align) or map to two distant genomic
  #' loci. The latter are termed chimeras and are considered to be artifacts of
  #' PCR amplification.
  failedReads <- keys[!keys$readPairKey %in% read.loci.mat$readPairKey,]
  chimera.reads <- failedReads[
    failedReads$R1 %in% hits.R1$qName & failedReads$R2 %in% hits.R2$qName,]
  
  chimera.alignments <- GRangesList(lapply(1:length(chimera.reads), function(i){
    R1 <- hits.R1[hits.R1$qName == chimera.reads[i, "R1"]]
    R2 <- hits.R2[hits.R2$qName == chimera.reads[i, "R2"]]
    names(R1) <- rep(chimera.reads[i, "names"], length(R1))
    names(R2) <- rep(chimera.reads[i, "names"], length(R2))
    c(R2, R1)
  }))
  
  chimeraData <- list(
    "read_info" = chimera.reads, "alignments" = chimera.alignments)
  save(chimeraData, file = "chimeraData.RData")
  
  #' Record chimera metrics
  chimeras <- length(unique(chimera.reads$names))
  stats <- cbind(stats, chimeras)
  save(stats, file="stats.RData")
  
  #' ########## IDENTIFY UNIQUELY-PAIRED READS (real sites) ##########
  #' Below, the paired.loci object is expanded to create the genomic alignments
  #' for each read that mapped to a single genomic loci. This data is then 
  #' recorded in two formats. "allSites" is a GRanges object where each row is a
  #' single read, while "sites.final" is a condensed form of the data where each
  #' row is a unique integration site with the width of the range refering to 
  #' the longest template aligned to the reference genome. 
  uniq.read.loci.mat <- read.loci.mat[
    read.loci.mat$readPairKey %in% uniq.readPairs,]
  
  uniq.templates <- paired.loci[
    match(uniq.read.loci.mat$lociPairKey, paired.loci$lociPairKey)]
  uniq.templates$readPairKeys <- NULL
  uniq.templates$readPairKey <- uniq.read.loci.mat$readPairKey
  
  uniq.keys <- keys[keys$readPairKey %in% uniq.readPairs,]
  uniq.reads <- uniq.templates[
    match(uniq.keys$readPairKey, uniq.templates$readPairKey)]
  names(uniq.reads) <- as.character(uniq.keys$names)
  uniq.reads$sampleName <- sapply(
    strsplit(as.character(uniq.keys$names), "%"), "[[", 1)
  uniq.reads$ID <- sapply(strsplit(as.character(uniq.keys$names), "%"), "[[", 2)
  
  allSites <- uniq.reads
  save(allSites, file="allSites.RData")

  sites.final <- dereplicateSites(allSites)
  if(length(sites.final)>0){
    sites.final$sampleName <- allSites[1]$sampleName
    sites.final$posid <- paste0(as.character(seqnames(sites.final)),
                                as.character(strand(sites.final)),
                                start(flank(sites.final, width=-1, start=TRUE)))
  }
  save(sites.final, file="sites.final.RData")
  
  #' Record metrics about unique alignments to the stats object
  numAllSingleReads <- length(allSites)
  stats <- cbind(stats, numAllSingleReads)
  numAllSingleSonicLengths <- length(unique(granges(allSites)))
  stats <- cbind(stats, numAllSingleSonicLengths)
  numUniqueSites <- length(sites.final)
  stats <- cbind(stats, numUniqueSites)

  #' Clean up environment for expansion and clustering of multihits
  rm(uniq.read.loci.mat, uniq.templates, uniq.keys, 
     uniq.reads, allSites, sites.final)
  gc()
  
  #' ########## IDENTIFY MULTIPLY-PAIRED READS (multihits) ##########
  #' Multihits are reads that align to multiple locations in the reference 
  #' genome. There are bound to always be a certain proportion of reads aligning
  #' to repeated sequence due to the high level degree of repeated DNA elements
  #' within genomes. The final object generated, "multihitData", is a list of 
  #' three objects. "unclusteredMultihits" is a GRanges object where every 
  #' alignment for every multihit read is present in rows. 
  #' "clusteredMultihitPositions" returns all the possible integration site 
  #' positions for the multihit. Lastly, "clusteredMultihitLengths" contains the
  #' length of the templates mapping to the multihit clusters, used for
  #' abundance calculations.
  unclusteredMultihits <- GRanges()
  clusteredMultihitPositions <- GRangesList()
  clusteredMultihitLengths <- list()
  
  if(length(multihit.readPairs) > 0){
    #' Only consider readPairKeys that aligned to multiple genomic loci
    multi.read.loci.mat <- read.loci.mat[
      read.loci.mat$readPairKey %in% multihit.readPairs,]
  
    multihit.templates <- paired.loci[
      paired.loci$lociPairKey %in% multi.read.loci.mat$lociPairKey]
    multihit.expansion.map <- multihit.templates$readPairKeys
    multihit.templates$readPairKeys <- NULL
    multihit.templates <- multihit.templates[Rle(
      values = 1:length(multihit.templates),
      lengths = sapply(multihit.expansion.map, length)
    )]
    multihit.templates$readPairKey <- unlist(multihit.expansion.map)
    
    #' As the loci are expanded from the paired.loci object, unique templates 
    #' and readPairKeys are present in the readPairKeys unlisted from the 
    #' paired.loci object.
    multihit.templates <- multihit.templates[
      multihit.templates$readPairKey %in% multi.read.loci.mat$readPairKey]
    
    multihit.keys <- keys[keys$readPairKey %in% multihit.readPairs,]
    multihit.keys$sampleName <- sapply(strsplit(
      as.character(multihit.keys$names), "%"), "[[", 1)
    multihit.keys$ID <- sapply(strsplit(
      as.character(multihit.keys$names), "%"), "[[", 2)

    #' Medians are based on all the potential sites for a given read, which will
    #' be identical for all reads associated with a readPairKey.
    multihit.medians <- round(
      median(width(split(multihit.templates, multihit.templates$readPairKey))))
    multihit.keys$medians <- multihit.medians[multihit.keys$readPairKey]
    
    multihits.pos <- flank(multihit.templates, -1, start = TRUE)
    multihits.red <- reduce(multihits.pos, min.gapwidth = 5L, with.revmap = TRUE)  #! Should make 5L a option
    revmap <- multihits.red$revmap
    
    axil_nodes <- as.character(Rle(
      values = multihit.templates$readPairKey[sapply(revmap, "[", 1)], 
      lengths = sapply(revmap, length)
    ))
    nodes <- multihit.templates$readPairKey[unlist(revmap)]
    edgelist <- unique(matrix( c(axil_nodes, nodes), ncol = 2 ))
    multihits.clusterData <- igraph::clusters(
      igraph::graph.edgelist(edgelist, directed=F))
    clus.key <- data.frame(
      row.names = unique(as.character(t(edgelist))),
      "clusID" = multihits.clusterData$membership)
    
    multihits.pos$clusID <- clus.key[multihits.pos$readPairKey, "clusID"]
    clusteredMultihitPositions <- split(multihits.pos, multihits.pos$clusID)
    clusteredMultihitNames <- lapply(
      clusteredMultihitPositions, function(x) unique(x$readPairKey))
    clusteredMultihitPositions <- GRangesList(lapply(
      clusteredMultihitPositions, 
      function(x){
        unname(unique(granges(x)))
    })) 
    
    clusteredMultihitLengths <- lapply(clusteredMultihitNames, function(x){
      readIDs <- unique(multihit.keys[multihit.keys$readPairKey %in% x,]$ID)
      data.frame(table(multihit.keys[multihit.keys$ID %in% readIDs,]$medians))
    })
    
    #' Expand the multihit.templates object from readPairKey specific to read
    #' specific.
    multihit.keys <- multihit.keys[order(multihit.keys$readPairKey),]
    multihit.readPair.read.exp <- IntegerList(lapply(
      unique(multihit.keys$readPairKey), 
      function(x){which(multihit.keys$readPairKey == x)}))
    names(multihit.readPair.read.exp) <- unique(multihit.keys$readPairKey)
    unclusteredMultihits <- multihit.templates
    multihit.readPair.read.exp <- as(multihit.readPair.read.exp[
      as.character(unclusteredMultihits$readPairKey)], "SimpleList")
    unclusteredMultihits <- unclusteredMultihits[Rle(
      values = 1:length(unclusteredMultihits),
      lengths = sapply(multihit.readPair.read.exp, length)
    )]
    names(unclusteredMultihits) <- multihit.keys$names[
      unlist(multihit.readPair.read.exp)]
    unclusteredMultihits$ID <- multihit.keys$ID[
      unlist(multihit.readPair.read.exp)]
    unclusteredMultihits$sampleName <- multihit.keys$sampleName[
      unlist(multihit.readPair.read.exp)]
  }
  
  stopifnot(length(clusteredMultihitPositions)==length(clusteredMultihitLengths))
  multihitData <- list(unclusteredMultihits, clusteredMultihitPositions, clusteredMultihitLengths)
  names(multihitData) <- c("unclusteredMultihits", "clusteredMultihitPositions", "clusteredMultihitLengths")
  
  save(multihitData, file="multihitData.RData")
  
  #' Record multihit metrics (reads, clusters, sonicLengths)
  multihitReads <- nrow(keys[keys$readPairKey %in% multihit.readPairs,])
  stats <- cbind(stats, multihitReads)

  multihitSonicLengths <- 0
  if( length(multihitData$clusteredMultihitLengths) > 0 ) {
    multihitSonicLengths <- sum(
      sapply(multihitData$clusteredMultihitLengths, nrow))
  }
  stats <- cbind(stats, multihitSonicLengths) 
  
  multihitClusters <- length(multihitData$clusteredMultihitPositions) 
  stats <- cbind(stats, multihitClusters)
  
  #' Finalize metrics by combining unique alignments and multihit clusters
  totalSonicLengths <- numAllSingleSonicLengths + multihitSonicLengths
  stats <- cbind(stats, totalSonicLengths)

  totalEvents <- numUniqueSites + multihitClusters
  stats <- cbind(stats, totalEvents)
  
  save(stats, file="stats.RData")
