#!/usr/bin/env Rscript
options(stringsAsFactors = FALSE)
suppressMessages(library("argparse"))
suppressMessages(library("pander"))

code_dir <- dirname(
  sub("--file=", "", grep("--file=", commandArgs(trailingOnly = FALSE), value = TRUE)))
  
# Set up and gather command line arguments
parser <- ArgumentParser(
  description = "R-based nucleotide sequence coupler for paired-end sequences aligned by BLAT.")
parser$add_argument(
  "anchorPSL", nargs = 1, type = "character", default = NULL,
  help = "Alignment file (psl format) to couple, component of paired-end sequence that is anchored to a biological phenomenon.")
parser$add_argument(
  "adriftPSL", nargs = 1, type = "character", default = NULL,
  help = "Alignment file (psl format) to couple, other component of paired-end sequnece that is generated by non-natural forces (shearing).")
parser$add_argument(
  "-k", "--keys", nargs = "*", type = "character", default = NULL,
  help = "Key files which denote the consolidation of reads to unique sequences. See README for requirements. Mulitple key files should be input in the same order as their respective psl files.")
parser$add_argument(
  "-o", "--uniqOutput", nargs = 1, type = "character", default = NULL,
  help = "Output file for unique alignments. File types supported: .rds, .RData, .csv, and .tsv")
parser$add_argument(
  "--condSites", nargs = 1, type = "character", default = NULL, 
  help = "Output file for condensed sites, based on anchor alignments. Read counts and unique alignment length counts are reported for each unique site. Same file types supported as uniqOutput.")
parser$add_argument(
  "--chimeras", nargs = 1, type = "character", default = NULL, 
  help = "Output file for chimeric alignments. Same file types supported as uniqOutput.")
parser$add_argument(
  "--multihits", nargs = 1, type = "character", default = NULL, 
  help = "Output file for multihit alignments. Same file types supported as uniqOutput.")
parser$add_argument(
  "-g", "--refGenome", nargs = 1, type = "character", default = "hg38",
  help = "Reference genome, needs to be installed through BSgenome (BioConductor).")
parser$add_argument(
  "--maxAlignStart", nargs = 1, type = "integer", default = 5L,
  help = "Maximum allowable distance from the start of the sequence to keep the alignment. Default = 5.")
parser$add_argument(
  "--minPercentIdenity", nargs = 1, type = "integer", default = 95L,
  help = "Minimal global (whole sequence) percent identity required to keep alignment. Default = 95 (0-100).")
parser$add_argument(
  "--minTempLength", nargs = 1, type = "integer", default = 30L,
  help = "Minimum value for paired template length to consider. Default = 30 (bps).")
parser$add_argument(
  "--maxTempLength", nargs = 1, type = "integer", default = 2500L,
  help = "Maximum value for paired template length to consider. Default = 2500 (bps).")
parser$add_argument(
  "--readNamePattern", nargs = 1, type = "character", default = "[\\w:-]+",
  help = "Regular expression for pattern matching read names. Should not contain R1/R2/I1/I2 specific components. Default is [\\w:-]+")

args <- parser$parse_args(commandArgs(trailingOnly = TRUE))

# Argument Conditionals

# Print Inputs to terminal
input_table <- data.frame(
  "Variables" = paste0(names(args), " :"), 
  "Values" = sapply(1:length(args), function(i){
    paste(args[[i]], collapse = ", ")}))
input_table <- input_table[
  match(c("anchorPSL :", "adriftPSL :", "keys :", "uniqOutput :", "condSites :", 
          "chimeras :", "multihits :", "refGenome :", "maxAlignStart :", 
          "minPercentIdenity :", "minTempLength :", "maxTempLength :", 
          "readNamePattern :"),
        input_table$Variables),]
pandoc.title("blatCoupleR Inputs")
pandoc.table(data.frame(input_table, row.names = NULL), 
             justify = c("left", "left"), 
             split.tables = Inf)

# Load additional R-packages for analysis and processing
add_packs <- c("stringr", "GenomicRanges", "igraph", 
               "data.table", "Matrix", "BSgenome")
add_packs_loaded <- suppressMessages(
  sapply(add_packs, require, character.only = TRUE))
if(!all(add_packs_loaded)){
  pandoc.table(data.frame(
    "R-Packages" = names(add_packs_loaded), 
    "Loaded" = add_packs_loaded, 
    row.names = NULL))
  stop("Check dependancies.")
}

# Load supporting scripts
source(file.path(
  code_dir, "supporting_scripts", "readKeyFile.R"))
source(file.path(
  code_dir, "supporting_scripts", "readPSL.R"))
source(file.path(
  code_dir, "supporting_scripts", "qualityFilter.R"))
source(file.path(
  code_dir, "supporting_scripts", "processBLATData.R"))
source(file.path(
  code_dir, "supporting_scripts", "condenseSites.R"))
source(file.path(
  code_dir, "supporting_scripts", "writeOutputFile.R"))
if(!all(c("readKeyFile", "readPSL", "qualityFilter", 
          "processBLATData", "condenseSites", "writeOutputFile") %in% ls())){
  stop("Cannot load supporting scripts. You may need to clone from github again.")
}

# Load reference genome
genome <- grep(args$refGenome, BSgenome::installed.genomes(), value = TRUE)
if(length(genome) == 0){
  pandoc.strong("Installed genomes include")
  pandoc.list(BSgenome::installed.genomes())
  stop("Selected reference genome not in list.")
}else if(length(genome) > 1){
  pandoc.strong("Installed genomes include")
  pandoc.list(BSgenome::installed.genomes())
  stop("Please be more specific about reference genome. Multiple matches to input.")
}
suppressMessages(library(genome, character.only = TRUE))
refGenome <- get(genome)

## Load and process alignment data ##
# Create single key file if one for each alignment file.
if(length(args$keys) > 1){
  anch_key_type <- str_extract(args$keys[1], "[\\w]+$")
  if(!keyType %in% c("csv", "tsv", "rds", "RData")){
    stop("Output key file type not supported. Please use csv, tsv, rds, or RData.")
  }
  anch_keys <- readKeyFile(args$keys[1], format = anch_key_type)
  
  adri_key_type <- str_extract(args$key[2], "[\\w]+$")
  if(!keyType %in% c("csv", "tsv", "rds", "RData")){
    stop("Output key file type not supported. Please use csv, tsv, rds, or RData.")
  }
  adri_keys <- readKeyFile(args$keys[2], format = adri_key_type)
  
  stopifnot(all(names(anch_keys) %in% c("readName", "seqID")))
  stopifnot(all(names(adri_keys) %in% c("readName", "seqID")))
  
  # Verify readNames are in the same format.
  anch_keys$readName <- str_extract(anch_keys$readName, args$readNamePattern)
  adri_keys$readName <- str_extract(adri_keys$readName, args$readNamePattern)
  
  # Only interested in reads in common between the two.
  common_names <- intersect(anch_keys$readNames, adri_keys$readNames)
  anch_keys <- anch_keys[anch_keys$readNames %in% common_names,]
  adri_keys <- adri_keys[adri_keys$readNames %in% common_names,]
  
  # Create a common key
  adri_keys <- adri_keys[match(anch_keys$readName, adri_keys$readName),]
  keys <- data.frame(
    "readNames" = anch_keys$readNames,
    "anchorSeqID" = anch_keys$seqID,
    "adriftSeqID" = adri_keys$seqID,
    "readPairKey" = paste0(anch_keys$seqID, ":", adri_keys$seqID))
}else if(length(args$key) == 1){
  key_type <- str_extract(args$keys, "[\\w]+$")
  if(!keys_type %in% c("csv", "tsv", "rds", "RData")){
    stop("Output key file type not supported. Please use csv, tsv, rds, or RData.")
  }
  keys <- readKeyFile(args$keys, format = key_type)
  stopifnot(all(c("readNames", "anchorSeqID", "adriftSeqID") %in% names(keys)))
  keys$readPairKey <- paste0(keys$anchorSeqID, ":", keys$adriftSeqID)
}else if(length(args$keys) > 2){
  stop("Cannot have more key files than sequence alignment files.")
}

# Load psl files and filter reads based on inputs
anch_hits <- readPSL(args$anchorPSL)
adri_hits <- readPSL(args$adriftPSL)
  
# Quality filter and convert alignments from data.frame to GRanges
anch_hits <- qualityFilter(
  anch_hits, args$maxAlignStart, args$minPercentIdentity)
anch_hits <- processBLATData(anch_hits, "anchor", refGenome)
  
adri_hits <- qualityFilter(
  adri_hits, args$maxAlignStart, args$minPercentIdentity)
adri_hits <- processBLATData(adri_hits, "adrift", refGenome)

# All alignments should be either "+" or "-" strand.  
stopifnot(all(strand(anch_hits) == "+" | strand(anch_hits) == "-"))
stopifnot(all(strand(adri_hits) == "+" | strand(adri_hits) == "-"))

# Identify all combinations of unique anchor and adrift sequences present in the data
unique_key_pairs <- unique(keys[,c("anchorSeqID", "adriftSeqID", "readPairKey")])

#' Reduced alignments identify the distinct genomic locations present in the 
#' data for the adrift sequences (breakpoint positions) and anchor sequences 
#' (integration site position). 
#' Levels: Reads --> Unique Sequences --> Alignments --> Unique Genomic Loci
red_anch_hits <- reduce(
  flank(anch_hits, -1, start = TRUE), min.gapwidth = 0L, with.revmap = TRUE)

red_adri_hits <- reduce(
  flank(adri_hits, -1, start = TRUE), min.gapwidth = 0L, with.revmap = TRUE)

#' The following finds all posible combinations of anchor and adrift loci which 
#' meet criteria for pairing. These include: oneEach (each pairing must come 
#' from one anchor and one adrift loci), opposite strands (paired loci should be
#' present on opposite strands), and correct downstream orientation (if an 
#' anchor loci is on the "+" strand, then the start of the anchor loci should be
#' less than the paired adrift, and vice versa for "-" strand).
#' (Inherent check for oneEach with findOverlaps())
pairs <- findOverlaps(
  red_anchor_hits,
  red_adrift_hits,
  maxgap = maxLength,
  ignore.strand = TRUE
)
  
anchor.loci <- red_anch_hits[queryHits(pairs)]
adrift.loci <- red_adri_hits[subjectHits(pairs)]
  
#' Check isDownstream and isOppositeStrand
adrift.loci.starts <- start(adrift.loci)
anchor.loci.starts <- start(anchor.loci)
  
adrift.loci.strand <- strand(adrift.loci)
anchor.loci.strand <- strand(anchor.loci)
  
keep.loci <- ifelse(
    anchor.loci.strand == "+", 
    as.vector(adrift.loci.starts > anchor.loci.starts & 
                adrift.loci.strand != anchor.loci.strand), 
    as.vector(adrift.loci.starts < anchor.loci.starts & 
                adrift.loci.strand != anchor.loci.strand))

keep.loci <- as.vector(
  keep.loci & anchor.loci.strand != "*" & adrift.loci.strand != "*")
  
anchor.loci <- anchor.loci[keep.loci]
adrift.loci <- adrift.loci[keep.loci]
  
#' Below, the code constructs a genomic loci key which links genomic loci to
#' the various anchor and adrift sequences that were aligned.
loci.key <- data.frame(
  "anchor.loci" = queryHits(pairs)[keep.loci],
  "adrift.loci" = subjectHits(pairs)[keep.loci])
loci.key$lociPairKey <- paste0(loci.key$anchor.loci, ":", loci.key$adrift.loci)

loci.key$anchor.qNames <- IntegerList(lapply(anchor.loci$revmap, function(x){
  as.integer(anch_hits$qName[x])
}))
  
loci.key$adrift.qNames <- IntegerList(lapply(adrift.loci$revmap, function(x){
  as.integer(adri_hits$qName[x])
}))
  
loci.key$anchor.readPairs <- IntegerList(lapply(
  loci.key$anchor.qNames, function(x){
    which(unique_key_pairs$anchorSeqID %in% x)
  }))
  
loci.key$adrift.readPairs <- IntegerList(lapply(
  loci.key$adrift.qNames, function(x){
    which(unique_key_pairs$adriftSeqID %in% x)
}))

#' Using the range information from the filtered paired alignments, the code
#' constructs a GRanges object from the anchor.loci and adrift.loci. anchor.loci
#' are the integration site positions while the adrift.loci are the various 
#' breakpoints. The strand of the range is set to the same strand as the 
#' anchor.loci since the direction of sequencing from the viral or vector genome
#' is from the U5-host junction found at the 3' end of the integrated element.
paired.loci <- GRanges(
  seqnames = seqnames(anchor.loci), 
  ranges = IRanges(
    start = ifelse(
      strand(anchor.loci) == "+", start(anchor.loci), start(adrift.loci)),
    end = ifelse(
      strand(anchor.loci) == "+", end(adrift.loci), end(anchor.loci))),
  strand = strand(anchor.loci),
  lociPairKey = loci.key$lociPairKey)
  
paired.loci$readPairKeys <- CharacterList(lapply(
  1:length(paired.loci), 
  function(i){
    unique_key_pairs[intersect(
      loci.key$anchor.readPairs[[i]], 
      loci.key$adrift.readPairs[[i]]),
      "readPairKey"]
}))
  
#' Remove anchor:adrift pairings that do not appear in the sequence data
paired.loci <- paired.loci[sapply(paired.loci$readPairKeys, length) > 0]

#' Expand readPairKeys and lociPairKeys to make a single object that maps loci
#' to unique sequences. This is analogous to a sparse matrix, but in a 
#' data.frame object. The keys object is still needed to jump from readPairKey
#' to readName.
read.loci.mat <- data.frame(
  "lociPairKey" = Rle(
    values = paired.loci$lociPairKey,
    lengths = sapply(paired.loci$readPairKeys, length)),
  "readPairKey" = unlist(paired.loci$readPairKeys)
)
  
#' Templates aligning to single loci are termed unique, while templates
#' aligning to multiple loci are termed multihits.
readPairCounts <- table(read.loci.mat$readPairKey)
uniq.readPairs <- names(readPairCounts[readPairCounts == 1])
multihit.readPairs <- names(readPairCounts[readPairCounts > 1])

#' ########## IDENTIFY IMPROPERLY-PAIRED READS (chimeras) ##########
#' Further, all unique and multihit templates were mapped successfully to 
#' genomic loci, yet some templates were sequenced but did not make it through
#' the selection criteria. These template either do not have alignments to the
#' reference genome (anchor or adrift did not align) or map to two distant 
#' genomic loci. The latter are termed chimeras and are considered to be 
#' artifacts of PCR amplification.
if(!is.null(args$chimeras)){
  failedReads <- keys[!keys$readPairKey %in% read.loci.mat$readPairKey,]
  chimera.reads <- failedReads[
    failedReads$anchorSeqID %in% anch_hits$qName & 
      failedReads$adriftSeqID %in% adri_hits$qName,]
  
  chimera.alignments <- GRangesList(lapply(1:length(chimera.reads), function(i){
    anchor <- anch_hits[anch_hits$qName == chimera.reads[i, "anchorSeqID"]]
    adrift <- adri_hits[adri_hits$qName == chimera.reads[i, "adriftSeqID"]]
    names(anchor) <- rep(chimera.reads[i, "names"], length(anchor))
    names(adrift) <- rep(chimera.reads[i, "names"], length(adrift))
    c(anchor, adrift)
  }))
  
  chimeraData <- list(
    "read_info" = chimera.reads, "alignments" = chimera.alignments)
  writeOutputFile(chimeraData, file = args$chimeras)
}

#' ########## IDENTIFY UNIQUELY-PAIRED READS ##########
#' Below, the paired.loci object is expanded to create the genomic alignments
#' for each read that mapped to a single genomic loci. This data is then 
#' recorded in two formats. "allSites" is a GRanges object where each row is a
#' single read, while "sites.final" is a condensed form of the data where each
#' row is a unique integration site with the width of the range refering to 
#' the longest template aligned to the reference genome. 
uniq.read.loci.mat <- read.loci.mat[
  read.loci.mat$readPairKey %in% uniq.readPairs,]

uniq.templates <- paired.loci[
  match(uniq.read.loci.mat$lociPairKey, paired.loci$lociPairKey)]
uniq.templates$readPairKeys <- NULL
uniq.templates$readPairKey <- uniq.read.loci.mat$readPairKey
  
uniq.keys <- keys[keys$readPairKey %in% uniq.readPairs,]
uniq.reads <- uniq.templates[
  match(uniq.keys$readPairKey, uniq.templates$readPairKey)]
names(uniq.reads) <- as.character(uniq.keys$readNames)
uniq.reads$sampleName <- unlist(strsplit(args$anchorPSL, "\\."))[1]
uniq.reads$ID <- names(uniq.reads)
  
uniq_sites <- uniq.reads
names(uniq_sites) <- NULL
writeOutputFile(uniq_sites, file = args$uniqOutput)

if(!is.null(args$condSites)){
  cond_sites <- condenseSites(
    uniq_sites, keep.cols = "sampleName", list.bp.counts = TRUE)
  writeOutputFile(cond_sites, file = args$condSites)
}
  
#' Clean up environment for expansion and clustering of multihits
rm(uniq.read.loci.mat, uniq.templates, uniq.keys, 
   uniq.reads, uniq_sites, cond_sites)
gc()
  
#' ########## IDENTIFY MULTIPLY-PAIRED READS (multihits) ##########
#' Multihits are reads that align to multiple locations in the reference 
#' genome. There are bound to always be a certain proportion of reads aligning
#' to repeated sequence due to the high level degree of repeated DNA elements
#' within genomes. The final object generated, "multihitData", is a list of 
#' three objects. "unclusteredMultihits" is a GRanges object where every 
#' alignment for every multihit read is present in rows. 
#' "clusteredMultihitPositions" returns all the possible integration site 
#' positions for the multihit. Lastly, "clusteredMultihitLengths" contains the
#' length of the templates mapping to the multihit clusters, used for
#' abundance calculations.
if(!is.null(args$multihits)){
  unclusteredMultihits <- GRanges()
  clusteredMultihitPositions <- GRangesList()
  clusteredMultihitLengths <- list()
  
  if(length(multihit.readPairs) > 0){
    #' Only consider readPairKeys that aligned to multiple genomic loci
    multi.read.loci.mat <- read.loci.mat[
      read.loci.mat$readPairKey %in% multihit.readPairs,]
  
    multihit.templates <- paired.loci[
      paired.loci$lociPairKey %in% multi.read.loci.mat$lociPairKey]
    multihit.expansion.map <- multihit.templates$readPairKeys
    multihit.templates$readPairKeys <- NULL
    multihit.templates <- multihit.templates[Rle(
      values = 1:length(multihit.templates),
      lengths = sapply(multihit.expansion.map, length)
    )]
    multihit.templates$readPairKey <- unlist(multihit.expansion.map)
    
    #' As the loci are expanded from the paired.loci object, unique templates 
    #' and readPairKeys are present in the readPairKeys unlisted from the 
    #' paired.loci object.
    multihit.templates <- multihit.templates[
      multihit.templates$readPairKey %in% multi.read.loci.mat$readPairKey]
    
    multihit.keys <- keys[keys$readPairKey %in% multihit.readPairs,]
    multihit.keys$sampleName <- sapply(strsplit(
      as.character(multihit.keys$names), "%"), "[[", 1)
    multihit.keys$ID <- sapply(strsplit(
      as.character(multihit.keys$names), "%"), "[[", 2)

    #' Medians are based on all the potential sites for a given read, which will
    #' be identical for all reads associated with a readPairKey.
    multihit.medians <- round(
      median(width(split(multihit.templates, multihit.templates$readPairKey))))
    multihit.keys$medians <- multihit.medians[multihit.keys$readPairKey]
    
    multihits.pos <- flank(multihit.templates, -1, start = TRUE)
    multihits.red <- reduce(multihits.pos, min.gapwidth = 5L, with.revmap = TRUE)  #! Should make 5L a option
    revmap <- multihits.red$revmap
    
    axil_nodes <- as.character(Rle(
      values = multihit.templates$readPairKey[sapply(revmap, "[", 1)], 
      lengths = sapply(revmap, length)
    ))
    nodes <- multihit.templates$readPairKey[unlist(revmap)]
    edgelist <- unique(matrix( c(axil_nodes, nodes), ncol = 2 ))
    multihits.clusterData <- igraph::clusters(
      igraph::graph.edgelist(edgelist, directed=F))
    clus.key <- data.frame(
      row.names = unique(as.character(t(edgelist))),
      "clusID" = multihits.clusterData$membership)
    
    multihits.pos$clusID <- clus.key[multihits.pos$readPairKey, "clusID"]
    clusteredMultihitPositions <- split(multihits.pos, multihits.pos$clusID)
    clusteredMultihitNames <- lapply(
      clusteredMultihitPositions, function(x) unique(x$readPairKey))
    clusteredMultihitPositions <- GRangesList(lapply(
      clusteredMultihitPositions, 
      function(x){
        unname(unique(granges(x)))
    })) 
    
    clusteredMultihitLengths <- lapply(clusteredMultihitNames, function(x){
      readIDs <- unique(multihit.keys[multihit.keys$readPairKey %in% x,]$ID)
      data.frame(table(multihit.keys[multihit.keys$ID %in% readIDs,]$medians))
    })
    
    #' Expand the multihit.templates object from readPairKey specific to read
    #' specific.
    multihit.keys <- multihit.keys[order(multihit.keys$readPairKey),]
    multihit.readPair.read.exp <- IntegerList(lapply(
      unique(multihit.keys$readPairKey), 
      function(x){which(multihit.keys$readPairKey == x)}))
    names(multihit.readPair.read.exp) <- unique(multihit.keys$readPairKey)
    unclusteredMultihits <- multihit.templates
    multihit.readPair.read.exp <- as(multihit.readPair.read.exp[
      as.character(unclusteredMultihits$readPairKey)], "SimpleList")
    unclusteredMultihits <- unclusteredMultihits[Rle(
      values = 1:length(unclusteredMultihits),
      lengths = sapply(multihit.readPair.read.exp, length)
    )]
    names(unclusteredMultihits) <- multihit.keys$names[
      unlist(multihit.readPair.read.exp)]
    unclusteredMultihits$ID <- multihit.keys$ID[
      unlist(multihit.readPair.read.exp)]
    unclusteredMultihits$sampleName <- multihit.keys$sampleName[
      unlist(multihit.readPair.read.exp)]
  }
  
  stopifnot(length(clusteredMultihitPositions)==length(clusteredMultihitLengths))
  multihitData <- list(unclusteredMultihits, clusteredMultihitPositions, clusteredMultihitLengths)
  names(multihitData) <- c("unclusteredMultihits", "clusteredMultihitPositions", "clusteredMultihitLengths")
  
  writeOutputFile(multihitData, file = args$multihits)
}
q()
